// This is automatically generated by PolySA
// Array type: SYNC

#include "Halide.h"
#include <iostream>

using namespace Halide;
using namespace std;

int main(void) {
// Input declarations
ImageParam V(type_of<int>(), 2, "V");
ImageParam d(type_of<int>(), 2, "d");

// Input initialization

// Variable declarations
Var t1, t2, t3;

// Function declarations
#define FUNC_S type_of<int>(), {t1, t2, t3}, Place::Host
Func d_CC1_E(FUNC_S), d_CC2_E(FUNC_S), V_CC0_I(FUNC_S), APP(FUNC_S);

// UREs
d_CC1_E(t1, t2, t3) = 0;
d_CC1_E(t1, t2, t3) = select((t1 - 1 == 0 && t3 - 1 >= 0), d(t3, t2), select((t1 - 2 >= 0 && t3 - 1 >= 0), d_CC1_E(t1 - 1, t2, t3), d_CC1_E(t1, t2, t3)));
d_CC2_E(t1, t2, t3) = 0;
d_CC2_E(t1, t2, t3) = select((t2 - 1 == 0 && t3 - 1 >= 0), d(t3, t1), select((t2 - 2 >= 0 && t3 - 1 >= 0), d_CC2_E(t1, t2 - 1, t3), d_CC2_E(t1, t2, t3)));
V_CC0_I(t1, t2, t3) = 0;
V_CC0_I(t1, t2, t3) = select((t3 == 0), 0, V_CC0_I(t1, t2, t3));
V_CC0_I(t1, t2, t3) = select((t3 - 1 >= 0), (V_CC0_I(t1, t2, t3 - 1) + ((d_CC1_E(t1, t2, t3) * d_CC2_E(t1, t2, t3)) / 8)), V_CC0_I(t1, t2, t3));
APP(t1, t2, t3) = 0;
APP(t1, t2, t3) = select((t3 - 8 == 0), V_CC0_I(t1, t2, t3), APP(t1, t2, t3));

// Build the initial loop nest
Var tloop1;
APP.merge_defs({d_CC1_E.update(0), d_CC2_E.update(0), V_CC0_I.update(0), V_CC0_I.update(1), APP.update(0)}, {d_CC1_E, d_CC2_E, V_CC0_I})
   .reorder_inward(t1, t2, t3)
   .space_time_transform({t1, t2, t3},
                         {tloop1},
                         {t2, t3},
                         {1, 0, 0,
                          0, 1, 0,
                          0, 0, 1},
                         {1, 0, 0,
                          0, 1, 0,
                          0, 0, 1})
   .domain(t1, 1, 8, 1,
           t2, 1, 8, 1,
           t3, 0, 8, 1,
           tloop1, 1, 8, 1);

// PE Optimization

// CPU Realization
Image<int> FPGA_output(8 + 1, 8 + 1, 8 + 1);
APP.realize(FPGA_output);
cout << "END" << endl;

// CPU Verification

/*
// Build I/O network
Func V_CC0_I_drainer, V_CC0_I_collector, V_CC0_I_unloader, V_CC0_I_deserializer(Place::Host), d_CC1_E_serializer(Place::Host), d_CC1_E_loader, d_CC1_E_feeder, d_CC2_E_serializer(Place::Host), d_CC2_E_loader, d_CC2_E_feeder;
APP.isolate_producer_chain(V_CC0_I, V_CC0_I_drainer, V_CC0_I_collector, V_CC0_I_unloader V_CC0_I_deserializer(Place::Host))
   .isolate_consumer_chain(d_CC1_E, d_CC1_E_feeder, d_CC1_E_loader, d_CC1_E_serializer(Place::Host))
   .isolate_consumer_chain(d_CC2_E, d_CC2_E_feeder, d_CC2_E_loader, d_CC2_E_serializer(Place::Host));

// I/O Optimization

*/
}
