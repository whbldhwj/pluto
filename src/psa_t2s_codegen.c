/*
 * PolySA: Polyhedral-Based Systolic Array Auto-Compiler
 *
 * Author: Jie Wang
 */
#include "pluto.h"
#include "psa_vsa.h"

/* 
 * This function generates T2S inputs
 */
void psa_t2s_codegen(FILE *fp, const VSA *vsa) {
  /* MISC info */
  fprintf(fp, "// This is automatically generated by PolySA\n\n");

  /* Input declarations */
  fprintf(fp, "// Input declarations\n");
  for (int i = 0; i < vsa->array_num; i++) {
    fprintf(fp, "ImageParam %s(type_of<%s>(), %d, \"%s\");\n", vsa->arrays[i]->text, 
        vsa->arrays[i]->data_type, vsa->arrays[i]->dim, vsa->arrays[i]->text);
  }
  fprintf(fp, "\n");

  /* Global setting */
  fprintf(fp, "// Global setting\n");
  fprintf(fp, "T2S.setting(LoopOrder::Inward, Place::Device);\n\n");

  /* Function declarations */
  fprintf(fp, "// Function declarations\n");
  fprintf(fp, "Func");
  int func_num = vsa->evar_num + vsa->edvar_num + vsa->ivar_num + vsa->idvar_num + 1;
  for (int i = 0; i < vsa->evar_num; i++) {
    fprintf(fp, " %s,", vsa->evar_names[i]);
  }
  for (int i = 0; i < vsa->edvar_num; i++) {
    fprintf(fp, " %s,", vsa->edvar_names[i]);
  }
  for (int i = 0; i < vsa->ivar_num; i++) {
    fprintf(fp, " %s,", vsa->ivar_names[i]);
  }
  for (int i = 0; i < vsa->idvar_num; i++) {
    fprintf(fp, " %s,", vsa->idvar_names[i]);
  }
  fprintf(fp, " APP;\n");
  fprintf(fp, "\n");

  /* Variable declarations */
  fprintf(fp, "// Variable declarations\n");
  fprintf(fp, "Var");
  for (int i = 0; i < vsa->t2s_iter_num; i++) {
    if (i == vsa->t2s_iter_num - 1) {
      fprintf(fp, " %s;\n", vsa->t2s_iters[i]);
    } else {
      fprintf(fp, " %s,", vsa->t2s_iters[i]);
    }
  }
  fprintf(fp, "\n");

  /* UREs */
  fprintf(fp, "// UREs\n");
  for (int i = 0; i < vsa->URE_num; i++) {
    fprintf(fp, "%s\n", vsa->UREs[i]->text);
  }
  fprintf(fp, "\n");

  /* URE domain */
  fprintf(fp, "// Build the initial loop nest\n");
  fprintf(fp, "APP.merge_UREs(");
  for (int i = 0; i < vsa->URE_num; i++) {
    if (i == 0) {
      fprintf(fp, vsa->UREs[i]->name);
    } else {
      fprintf(fp, ", %s", vsa->UREs[i]->name);
    }
  }
  fprintf(fp, ")\n");
  fprintf(fp, "   .domain(");
//  for (int i = 0; i < vsa->domain_exp_num; i++) {
//    if (i < vsa->domain_exp_num - 1) {
//      fprintf(fp, "%s,\n", vsa->domain_exps[i]);
//    } else {
//      fprintf(fp, "%s", vsa->domain_exps[i]);
//    }
//  }
  for (int i = 0; i < vsa->t2s_iter_num; i++) {
    if (i == 0) {
      fprintf(fp, "%s, %s, %s, %s,\n", 
          vsa->t2s_meta_iters[i]->iter_name,
          vsa->t2s_meta_iters[i]->lb,
          vsa->t2s_meta_iters[i]->ub,
          vsa->t2s_meta_iters[i]->stride);
    } else if (i < vsa->t2s_iter_num - 1) {
      fprintf(fp, "           %s, %s, %s, %s,\n", 
          vsa->t2s_meta_iters[i]->iter_name,
          vsa->t2s_meta_iters[i]->lb,
          vsa->t2s_meta_iters[i]->ub,
          vsa->t2s_meta_iters[i]->stride);
    } else {
      fprintf(fp, "           %s, %s, %s, %s", 
          vsa->t2s_meta_iters[i]->iter_name,
          vsa->t2s_meta_iters[i]->lb,
          vsa->t2s_meta_iters[i]->ub,
          vsa->t2s_meta_iters[i]->stride);
    }
  }
  fprintf(fp, ");\n\n");

  /* Optimization */
  fprintf(fp, "// Optimization\n") ;

  fprintf(fp, "\n");

  /* Space-time transformation */
  // NOTICE: we will have to call t2s_iter_extract again after the PE optimization
  fprintf(fp, "// Space-time transformation\n");
  fprintf(fp, "APP.space_time_transform(");
  int line_num = 0;
  char **lines = t2s_space_time_pprint(vsa, &line_num);
  for (int i = 0; i < line_num; i++) {
    if (i == 0) {
      fprintf(fp, "%s\n", lines[i]);
    } else if (i < line_num - 1) {
      fprintf(fp, "                         %s\n", lines[i]);
    } else {
      fprintf(fp, "                         %s", lines[i]);
    }
  }
  fprintf(fp, ");\n\n");

  /* I/O network */
  fprintf(fp, "// Build I/O network\n");
  fprintf(fp, "Func ");
  for (int i = 0; i < vsa->t2s_IO_func_num; i++) {
    if (i > 0) {
      fprintf(fp, ", ");
    }
    fprintf(fp, "%s", vsa->t2s_IO_func_names[i]);
  }
  fprintf(fp, ";\n");
  fprintf(fp, "APP");
  for (int i = 0; i < vsa->t2s_IO_build_num; i++) {
    if (i == 0) {
      fprintf(fp, ".%s\n", vsa->t2s_IO_build_calls[i]);
    } else if (i < vsa->t2s_IO_build_num - 1) {
      fprintf(fp, "   .%s\n", vsa->t2s_IO_build_calls[i]);
    } else {
      fprintf(fp, "   .%s;\n", vsa->t2s_IO_build_calls[i]);
    }
  }
  fprintf(fp, "\n");

  /* I/O network spec */
  fprintf(fp, "// Specialize I/O network\n");

  fprintf(fp, "\n");
}

/* 
 * Print out the space_time transform in T2S spec
 */
char **t2s_space_time_pprint(VSA *vsa, int *line_num) {
  // T2S progam only contains one perfectly nested loop
  int time_band_width = vsa->t2s_iter_num - vsa->array_part_band_width - vsa->space_band_width;

  int total_line_num = 1 + 1 + vsa->space_band_width + 1 
    + time_band_width + 1;
  char **lines = (char **)malloc(total_line_num * sizeof(char *));
  // print the source loops
  {
    char *str = "{";
    for (int i = 0; i < vsa->t2s_iter_num; i++) {
      if (i > 0) {
        str = concat(str, ", ");
      }
      str = concat(str, vsa->t2s_iters[i]);
    }
    str = concat(str, "},");
    lines[*line_num] = str;
    *line_num = *line_num + 1;
  }

  // print the space loops
  {
    char *str = "{";
    for (int i = vsa->array_part_band_width; i < vsa->array_part_band_width + vsa->space_band_width; i++) {
      if (i - vsa->array_part_band_width > 0) {
        str = concat(str, ", ");
      }
      str = concat(str, vsa->t2s_iters[i]);
    }
    str = concat(str, "},");
    lines[*line_num] = str;
    *line_num = *line_num + 1;
  
    // print the space transform
    for (int row = 0; row < vsa->space_band_width; row++) {
      char *str = "";
      if (row == 0)
        str = concat(str, "{");
      else
        str = concat(str, " ");
      for (int col = 0; col < vsa->t2s_iter_num; col++) {
        if (col > 0)
          str = concat(str, ", ");
        if (col == vsa->array_part_band_width + row)
          str = concat(str, "1");
        else
          str = concat(str, "0");      
      }
      if (row < vsa->space_band_width - 1)
        str = concat(str, ",");
      else
        str = concat(str, "},");
      lines[*line_num] = str;
      *line_num = *line_num + 1;
    }
  }

  // print the time loops
  {
    char *str = "{";
    for (int i = vsa->array_part_band_width + vsa->space_band_width; i < vsa->array_part_band_width + vsa->space_band_width + time_band_width; i++) {
      if (i - vsa->array_part_band_width - vsa->space_band_width > 0) {
        str = concat(str, ", ");
      }
      str = concat(str, vsa->t2s_iters[i]);
    }
    str = concat(str, "},");
    lines[*line_num] = str;
    *line_num = *line_num + 1;

    // print the time transform
    for (int row = 0; row < time_band_width; row++) {
      char *str = "";
      if (row == 0)
        str = concat(str, "{");
      else
        str = concat(str, " ");
      for (int col = 0; col < vsa->t2s_iter_num; col++) {
        if (col > 0)
          str = concat(str, ", ");
        if (col == vsa->array_part_band_width + vsa->space_band_width + row)
          str = concat(str, "1");
        else
          str = concat(str, "0");
      }
      if (row < time_band_width - 1)
        str = concat(str, ",");
      else
        str = concat(str, "},");
      lines[*line_num] = str;
      *line_num = *line_num + 1;
    }
  }

  // array time
  {
    char *str = "Systolic::Async";
    lines[*line_num] = str;
    *line_num = *line_num + 1;
  }

  return lines;
}
