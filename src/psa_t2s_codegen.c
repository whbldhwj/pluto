/*
 * PolySA: Polyhedral-Based Systolic Array Auto-Compiler
 *
 * Author: Jie Wang
 */
#include "pluto.h"
#include "psa_vsa.h"
#include "psa_knobs.h"

/* 
 * This function generates T2S inputs
 */
void psa_t2s_codegen(FILE *fp, const VSA *vsa) {
  /* MISC info */
  fprintf(fp, "// This is automatically generated by PolySA\n");
#ifdef SYNC_ARRAY
  fprintf(fp, "// Array type: SYNC\n");
#endif
#ifdef ASYNC_ARRAY
  fprintf(fp, "// Array type: ASYNC\n");
#endif  
  fprintf(fp, "\n");

  /* Headers */
  fprintf(fp, "#include \"Halide.h\"\n");
  fprintf(fp, "#include <iostream>\n\n");

  fprintf(fp, "using namespace Halide;\n");
  fprintf(fp, "using namespace std;\n\n");

  fprintf(fp, "int main(void) {\n");

  /* Input declarations */
  fprintf(fp, "// Input declarations\n");
  for (int i = 0; i < vsa->array_num; i++) {
    fprintf(fp, "ImageParam %s(type_of<%s>(), %d, \"%s\");\n", vsa->arrays[i]->text, 
        vsa->arrays[i]->data_type, vsa->arrays[i]->dim, vsa->arrays[i]->text);
  }
  fprintf(fp, "\n");

  /* Global setting */
//  fprintf(fp, "// Global setting\n");
//  fprintf(fp, "T2S.setting(LoopOrder::Inward, Place::Device);\n\n");

  /* Initialization */
  fprintf(fp, "// Input initialization\n");
  fprintf(fp, "\n");

  /* Variable declarations */
  fprintf(fp, "// Variable declarations\n");
  fprintf(fp, "Var");
  for (int i = 0; i < vsa->t2s_iter_num; i++) {
    if (i == vsa->t2s_iter_num - 1) {
      fprintf(fp, " %s;\n", vsa->t2s_iters[i]);
    } else {
      fprintf(fp, " %s,", vsa->t2s_iters[i]);
    }
  }
  fprintf(fp, "\n");

  /* Function declarations */
  fprintf(fp, "// Function declarations\n");
  fprintf(fp, "#define FUNC_S type_of<int>(), {");
  for (int i = 0; i < vsa->t2s_iter_num; i++) {
    if (i == 0) 
      fprintf(fp, "%s", vsa->t2s_iters[i]);
    else
      fprintf(fp, ", %s", vsa->t2s_iters[i]);
  }
  fprintf(fp, "}, Place::Host\n");
  
  fprintf(fp, "Func");
  int func_num = vsa->evar_num + vsa->edvar_num + vsa->ivar_num + vsa->idvar_num + 1;
  for (int i = 0; i < vsa->evar_num; i++) {
    fprintf(fp, " %s(FUNC_S),", vsa->evar_names[i]);
   }  
//  for (int i = 0; i < vsa->edvar_num; i++) {
//    fprintf(fp, " %s,", vsa->edvar_names[i]);
//  }
  for (int i = 0; i < vsa->ivar_num; i++) {
    fprintf(fp, " %s(FUNC_S),", vsa->ivar_names[i]);
  }
//  for (int i = 0; i < vsa->idvar_num; i++) {
//    fprintf(fp, " %s,", vsa->idvar_names[i]);
//  }
  fprintf(fp, " APP(FUNC_S);\n");
  fprintf(fp, "\n");

  /* UREs */
  fprintf(fp, "// UREs\n");
  for (int i = 0; i < vsa->URE_num; i++) {
    fprintf(fp, "%s\n", vsa->UREs[i]->text);
  }
  fprintf(fp, "\n");

  /* URE domain */
  fprintf(fp, "// Build the initial loop nest\n");
  fprintf(fp, "Var ");
  for (int i = 0; i < vsa->time_band_width; i++) {
    if (i == 0) {
      fprintf(fp, "tloop%d", i + 1);
    } else {
      fprintf(fp, ", tloop%d", i + 1);
    }
  }
  fprintf(fp, ";\n");

  fprintf(fp, "APP.merge_defs(");
  for (int i = 0; i < vsa->URE_num - 1; i++) {
    if (i == 0) {
      fprintf(fp, vsa->UREs[i]->name);
    } else {
      fprintf(fp, ", %s", vsa->UREs[i]->name);
    }
  }
  fprintf(fp, ")\n");
  fprintf(fp, "   .reorder_inward(");
  for (int i = 0; i < vsa->t2s_iter_num; i++) {
    if (i == 0)
      fprintf(fp, "%s", vsa->t2s_iters[i]);
    else
      fprintf(fp, ", %s", vsa->t2s_iters[i]);
  }
  fprintf(fp, ")\n");

  /* Space-time transformation */
  // NOTICE: we will have to call t2s_iter_extract again after the PE optimization  
  fprintf(fp, "   .space_time_transform(");  
  int line_num = 0;
  char **lines = t2s_space_time_pprint(vsa, &line_num);
  for (int i = 0; i < line_num; i++) {
    if (i == 0) {
      fprintf(fp, "%s\n", lines[i]);
    } else if (i < line_num - 1) {
      fprintf(fp, "                         %s\n", lines[i]);
    } else {
      fprintf(fp, "                         %s", lines[i]);
    }
  }
  fprintf(fp, ")\n");
  for (int i = 0; i < line_num; i++) {
    free(lines[i]);
  }
  free(lines);

  /* Domain */
  // Notice: the loop bound is shited by one due to the limitation of Halide
  fprintf(fp, "   .domain(");  
  for (int i = 0; i < vsa->t2s_iter_num; i++) {
    if (i == 0) {
      fprintf(fp, "%s, %s, %s, %s,\n", 
          vsa->t2s_meta_iters[i]->iter_name,
          vsa->t2s_meta_iters[i]->lb,
          vsa->t2s_meta_iters[i]->ub,
          vsa->t2s_meta_iters[i]->stride);
    } else if (i < vsa->t2s_iter_num - 1) {
      fprintf(fp, "           %s, %s, %s, %s,\n", 
          vsa->t2s_meta_iters[i]->iter_name,
          vsa->t2s_meta_iters[i]->lb,
          vsa->t2s_meta_iters[i]->ub,
          vsa->t2s_meta_iters[i]->stride);
    } else {
      fprintf(fp, "           %s, %s, %s, %s,\n", 
          vsa->t2s_meta_iters[i]->iter_name,
          vsa->t2s_meta_iters[i]->lb,
          vsa->t2s_meta_iters[i]->ub,
          vsa->t2s_meta_iters[i]->stride);
    }
  }
  // Add the time iterators
  int titer_cnt = 0;
  for (int i = 0; i < vsa->t2s_iter_num; i++) {
    if (vsa->t2s_meta_iters[i]->type == 'T') {
      if (titer_cnt < vsa->time_band_width - 1) {
        fprintf(fp, "           tloop%d, %s, %s, %s,\n", 
            titer_cnt + 1,
            vsa->t2s_meta_iters[i]->lb,
            vsa->t2s_meta_iters[i]->ub,
            vsa->t2s_meta_iters[i]->stride);
      } else {
        fprintf(fp, "           tloop%d, %s, %s, %s", 
            titer_cnt + 1,
            vsa->t2s_meta_iters[i]->lb,
            vsa->t2s_meta_iters[i]->ub,
            vsa->t2s_meta_iters[i]->stride);
      }
      titer_cnt++;
    }
  }

  fprintf(fp, ");\n\n");

  /* Optimization */
  fprintf(fp, "// PE Optimization\n") ;

  fprintf(fp, "\n");

  /* Realization on CPU */
  fprintf(fp, "// CPU Realization\n");
  fprintf(fp, "Image<int> FPGA_output(");
  for (int i = 0; i < vsa->t2s_iter_num; i++) {
    if (i == 0) {
      fprintf(fp, "%s + 1", vsa->t2s_meta_iters[i]->ub);
    } else {
      fprintf(fp, ", %s + 1", vsa->t2s_meta_iters[i]->ub);
    }
  }
  fprintf(fp, ");\n");
  fprintf(fp, "APP.realize(FPGA_output);\n");
  fprintf(fp, "cout << \"END\" << endl;\n\n");

  /* CPU verification */
  fprintf(fp, "// CPU Verification\n");
  fprintf(fp, "\n");

  /* Temporarily disabled */
  fprintf(fp, "/*\n");
  /* I/O network */
  fprintf(fp, "// Build I/O network\n");
  fprintf(fp, "Func ");
  for (int i = 0; i < vsa->t2s_IO_func_num; i++) {
    if (i > 0) {
      fprintf(fp, ", ");
    }
    fprintf(fp, "%s", vsa->t2s_IO_func_names[i]);
  }
  fprintf(fp, ";\n");
  fprintf(fp, "APP");
  for (int i = 0; i < vsa->t2s_IO_build_num; i++) {
    if (i == 0) {
      fprintf(fp, ".%s\n", vsa->t2s_IO_build_calls[i]);
    } else if (i < vsa->t2s_IO_build_num - 1) {
      fprintf(fp, "   .%s\n", vsa->t2s_IO_build_calls[i]);
    } else {
      fprintf(fp, "   .%s;\n", vsa->t2s_IO_build_calls[i]);
    }
  }
  fprintf(fp, "\n");

  /* I/O network spec */
  fprintf(fp, "// I/O Optimization\n");

  fprintf(fp, "\n");
  fprintf(fp, "*/\n");

  fprintf(fp, "}\n");
}

/* 
 * Print out the space_time transform in T2S spec
 */
char **t2s_space_time_pprint(VSA *vsa, int *line_num) {
  // T2S progam only contains one perfectly nested loop
  int time_band_width = vsa->t2s_iter_num - vsa->array_part_band_width - vsa->space_band_width;

  int total_line_num = 1 + 1 + 1 + vsa->t2s_iter_num + vsa->t2s_iter_num;
  char **lines = (char **)malloc(total_line_num * sizeof(char *));
  // print the source loops
  {
    char *str = "";
    str = concat(str, "{");
    for (int i = 0; i < vsa->t2s_iter_num; i++) {
      if (i > 0) {
        str = concat(str, ", ");
      }
      str = concat(str, vsa->t2s_iters[i]);
    }
    str = concat(str, "},");
    lines[*line_num] = str;
    *line_num = *line_num + 1;
  }

  // print the time loops
  {
    char *str = "";
    str = concat(str, "{");
    for (int i = 0; i < vsa->time_band_width; i++) {
      char iter_str[10];
      sprintf(iter_str, "tloop%d", i + 1);
      if (i == 0)
        str = concat(str, iter_str);
      else {
        str = concat(str, ", ");
        str = concat(str, iter_str);
      }
    }
    str = concat(str, "},");
    lines[*line_num] = str;
    *line_num = *line_num + 1;
  }

  // print the space loops
  {
    char *str = "";
    str = concat(str, "{");
#ifdef ASYNC_ARRAY
    for (int i = vsa->array_part_band_width; i < vsa->array_part_band_width + vsa->space_band_width; i++) {
      if (i - vsa->array_part_band_width > 0) {
        str = concat(str, ", ");
      }
      str = concat(str, vsa->t2s_iters[i]);
    }
    str = concat(str, "},");
    lines[*line_num] = str;
    *line_num = *line_num + 1;
#endif
#ifdef SYNC_ARRAY
    for (int i = vsa->array_part_band_width + vsa->time_band_width; i < vsa->array_part_band_width + vsa->time_band_width + vsa->space_band_width; i++) {
      if (i - vsa->array_part_band_width - vsa->time_band_width > 0) {
        str = concat(str, ", ");
      }
      str = concat(str, vsa->t2s_iters[i]);
    }
    str = concat(str, "},");
    lines[*line_num] = str;
    *line_num = *line_num + 1;
#endif    
  }

  // print the transform
  {
    for (int row = 0; row < vsa->t2s_iter_num; row++) {
      char *str = "";
      if (row == 0) 
        str = concat(str, "{");
      else 
        str = concat(str, " ");
      for (int col = 0; col < vsa->t2s_iter_num; col++) {
        if (col > 0)
          str = concat(str, ", ");
        if (col == row)
          str = concat(str, "1");
        else
          str = concat(str, "0");
      }
      if (row < vsa->t2s_iter_num - 1) 
        str = concat(str, ",");
      else 
        str = concat(str, "},");
      lines[*line_num] = str;
      *line_num = *line_num + 1;
    }
  }

  // print the reverse transform
  {
    for (int row = 0; row < vsa->t2s_iter_num; row++) {
      char *str = "";
      if (row == 0) 
        str = concat(str, "{");
      else 
        str = concat(str, " ");
      for (int col = 0; col < vsa->t2s_iter_num; col++) {
        if (col > 0)
          str = concat(str, ", ");
        if (col == row)
          str = concat(str, "1");
        else
          str = concat(str, "0");
      }
      if (row < vsa->t2s_iter_num - 1) 
        str = concat(str, ",");
      else 
        str = concat(str, "}");
      lines[*line_num] = str;
      *line_num = *line_num + 1;
    }
  }

//  // array time
//  {
//    char *str = "Systolic::Async";
//    lines[*line_num] = str;
//    *line_num = *line_num + 1;
//  }

  return lines;
}
